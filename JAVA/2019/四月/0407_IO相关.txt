原文：https://juejin.im/post/5c20c0ece51d454ad55f27e0

1、IO流主要分为字符流和字节流。字节流中有抽象类InputStream和OutputStream，它们的子类FileInputStream，FileOutputStream,BufferedOutputStream等。字符流BufferedReader和Writer等。都实现了Closeable, Flushable, Appendable这些接口。程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。

2、字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件。

3、字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的；中文等文本数据用字符流，歌曲、图片等用字节流。

4、缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源，将一部分数据暂时读写到缓存区。
	Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作。
	
5、装饰器模式：就是动态地给一个对象添加一些额外的职责（对于原有功能的扩展）：
	1.它必须持有一个被装饰的对象（作为成员变量）。
	2.它必须拥有与被装饰对象相同的接口（多态调用、扩展需要）。
	3.它可以给被装饰对象添加额外的功能。
	
6、适配器模式：将一个类的接口转换成客户期望的另一个接口，让原本不兼容的接口可以合作无间。//把FileInputStream文件字节流适配成InputStreamReader字符流来操作文件字符串。
	FileInputStream fileInput = new FileInputStream(file); 
	InputStreamReader inputStreamReader = new InputStreamReader(fileInput);
	1.适配器对象实现原有接口
	2.适配器对象组合一个实现新接口的对象
	3.对适配器原有接口方法的调用被委托给新接口的实例的特定方法(重写旧接口方法来调用新接口功能。)
	
7、NIO和IO的主要区别：面向流与面向缓冲、阻塞与非阻塞IO、选择器。

8、clone:如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

9、BufferedInputStream是InputStream的缓冲流，使用它可以防止每次读取数据时进行实际的写操作，代表着使用缓冲区。不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多！并且也可以减少对磁盘的损伤。
