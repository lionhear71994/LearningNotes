原文：https://juejin.im/post/5c20c27551882504bd0e6f6d

1、线程池好处：
	1）降低资源消耗；
	2）提高相应速度；
	3）提高线程的可管理性。         

	
2、线程池的实现原理：
	当提交一个新任务到线程池时，判断核心线程池里的线程是否都在执行。如果不是，则创建一个新的线程执行任务。如果核心线程池的线程都在执行任务，则进入下个流程。
	判断工作队列是否已满。如果未满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。
	判断线程池是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果满了，则交给饱和策略来处理这个任务。

3、Thread类：start(),run(),wait(),sleep(),yield(),join()

4、预防死锁的产生:	
	打破互斥条件,即允许进程同时访问某些资源。
	打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。
	打破占有且申请条件。可以实行资源预先分配策略。
	打破循环等待条件，实行资源有序分配策略

5、ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
	ThreadLocal类是一个Map，Map中元素的键为线程对象，而值为对应线程的变量副本。
	
6、线程安全就是当多个线程访问一个对象时，不用考虑多线程的调度和交替执行，也可以保证该对象获得正确结果。
	
7、	线程安全级别：
	不可变：像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值。
	绝对线程安全：CopyOnWriteArrayList、CopyOnWriteArraySet。
	相对线程安全：Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。
	以及ArrayList、HashMap等非线程安全
	
8、ReentrantLock与synchronized的不同：
	等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
	公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。而synchronized是非公平的，即在锁被释放时，任何一个等待锁的线程都有机会获得锁。ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数改用公平锁。
	锁绑定多个条件：一个ReentrantLock对象可以通过多次调用newCondition()同时绑定多个Condition对象。而在synchronized中，锁对象wait()和notify()或notifyAl()只能实现一个隐含的条件，若要和多于一个的条件关联不得不额外地添加一个锁。
	
9、ReentrantLock适用场景：
	某个线程在等待一个锁的控制权的这段时间需要中断
	需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程，锁可以绑定多个条件。
	具有公平锁功能，每个到来的线程都将排队等候。
	
10、Java内存模型 JMM
	JMM可以屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。
	JMM决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：共享变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存（Local Memory），本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。
	
11、volatile：
	1.当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去；当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
　　2.这个写会操作会导致其他线程中的缓存无效。
	3.禁止指令重排序优化。重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。
	volatile对于单个的共享变量的读/写具有原子性，但是像num++这种复合操作，volatile无法保证其原子性
	
12、Synchronized
	1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
	2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
	3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
	4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。
	synchronized修饰方法时不能被继承，子类也需显式写出synchronized
	构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。
	
13、Volatile和Synchronized区别
	1 粒度不同，前者针对变量 ，后者锁对象和类
	2 syn阻塞，volatile线程不阻塞
	3 syn保证三大特性，volatile不保证原子性
	4 syn编译器优化，volatile不优化(禁止重排)
	
14、Synchronize在编译时如何实现锁机制？
	Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。

15、Thread.sleep(0)的作用:由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。

16、线程状态：
	a.新建（New）：线程创建后尚未启动
	b.包括正在执行（Running）和等待着CPU为它分配执行时间（Ready）两种 无限期等待（Waiting）：该线程不会被分配CPU执行时间，要等待被其他线程显式地唤醒。
	c.限期等待（Timed Waiting）：该线程不会被分配CPU执行时间，但在一定时间后会被系统自动唤醒。
	d.阻塞（Blocked）：线程被阻塞。和等待状态不同的是，阻塞状态表示在等待获取到一个排他锁，在另外一个线程放弃这个锁的时候发生；而等待状态表示在等待一段时间或者唤醒动作的发生，在程序等待进入同步区域的时候发生。
	e.结束（Terminated）：线程已经结束执行
	

